// Jazz schema for LA
// if field does not have `co.optional` it is required
// rule: list all required fields first, then optional fields
// rule: any field that is generated by AI, should be prefixed with `ai`, e.g. `aiSummary`
// TODO: move more fields from old edgedb schema to jazz (where it makes sense): https://github.com/learn-anything/explore/blob/main/archive/api/edgedb/dbschema/default-latest.esdl
// TODO: all instances of (unique) should be enforced by jazz itself, it means that only one instance with that name of field can exist
// sadly jazz does not allow enforcing that, so solutions for (unique) fields is: ignore duplicates or create a supporting look up structure (CoMap.Record from url to GlobalLink) and then Iâ€™ll let you know once the better way exists
// open issue about it: https://github.com/gardencmp/jazz/issues/44
// TODO: figure out how to do default values, e.g. `GlobalLink.protocol` should have default value `https` so we don't have to supply it every time in code..
// TODO: can jazz support vector fields? e.g. `GlobalLinkAiSummary.vectorContent`, would be nice to store website content as vector for semantic search
import { CoMap, CoList, co, Account, Group, Encoders } from "jazz-tools"
import { PersonalPageLists } from "./personal-page"
import { PersonalLinkLists } from "./personal-link"

// GlobalLink is link with unique URL that holds some useful metadata. Can be used to do queries like `most popular links added by users` etc.
export class GlobalLink extends CoMap {
  url = co.string // url without the protocol (e.g. "learn-anything.xyz") (unique)
  urlTitle = co.string // title of the page (as grabbed from url itself)
  protocol = co.literal("https") // TODO: other protocols? perhaps should be `co.string` for user custom protocols?
  aiSummary = co.optional.ref(GlobalLinkAiSummary) // TODO: should probably be a list? with allowing users to vote on results so 'top' one can be shown too
  summary = co.optional.ref(GlobalLinkSummary) // the very 'best' summary of link (can be part AI generated, part human written, whatever is best)
  urlWasCreatedOnInternetAt = co.optional.encoded(Encoders.Date) // date url was created on internet at (can pass just year or year+month or year+month+day)
  globalMainTopic = co.optional.ref(GlobalTopic) // each global link can have one main topic (to closest approximation)
  public = co.optional.boolean // if true, link is accessible from global search
  processed = co.optional.encoded(Encoders.Date) // date link was processed at by LA (update metadata etc.)
  // websiteDown = co.boolean // if website is 404 or down TODO: add it later when we have service to check for dead links
}
// GlobalLinkAiSummary is high quality title, description, summary of link (generated by AI)
export class GlobalLinkAiSummary extends CoMap {
  link = co.ref(GlobalLink) // link the summary is for
  aiModelUsed = co.string // model used to generate summary, e.g. "gpt-4o"
  title = co.string // high quality title of link
  description = co.string // high quality description of link
  summary = co.string // high quality summary of link
  // vectorContent = co.optional.vector // vector content of link, TODO: jazz needs support for this
}
// GlobalLinkSummary is high quality title, description, summary of link
export class GlobalLinkSummary extends CoMap {
  link = co.ref(GlobalLink) // link the summary is for
  title = co.string // high quality title of link
  description = co.string // high quality description of link
  summary = co.string // high quality summary of link
}

// GlobalTopic is topic that is accessible from `learn-anything.xyz/name`
export class GlobalTopic extends CoMap {
  name = co.string // name of topic, used for url `learn-anything.xyz/name` (unique)
  prettyName = co.string // pretty name of topic, e.g. "React"
  aiSummary = co.optional.ref(GlobalTopicAiSummary) // high quality summary of topic (generated by AI)
  humanSummary = co.optional.string // human created summary of link (simplified, cleaner)
  topicAiSummary = co.optional.string // summary of topic (generated by AI)
  topicSummary = co.optional.string // summary of topic (generated by AI)
  public = co.optional.boolean // if true, topic is accessible from global search
}
// GlobalTopicAiSummary is high quality summary of topic (generated by AI)
export class GlobalTopicAiSummary extends CoMap {
  topic = co.ref(GlobalTopic) // topic the summary is for
  aiModelUsed = co.string // model used to generate summary, e.g. "gpt-4o"
  summary = co.string // high quality summary of topic (generated by AI)
}

class ListOfTopics extends CoList.Of(co.ref(GlobalTopic)) {}
class UserProfile extends CoMap {
  name = co.string
  // TODO: avatar
}
export class UserRoot extends CoMap {
  name = co.string
  username = co.string
  website = co.string
  bio = co.string

  personalLinks = co.ref(PersonalLinkLists)
  personalPages = co.ref(PersonalPageLists)

  // not implemented yet
  topicsWantToLearn = co.ref(ListOfTopics)
  topicsLearning = co.ref(ListOfTopics)
  topicsLearned = co.ref(ListOfTopics)
}
export class LaAccount extends Account {
  profile = co.ref(UserProfile)
  root = co.ref(UserRoot)
  async migrate(
    this: LaAccount,
    creationProps?:
      | { name: string; username: string; website: string; bio: string }
      | undefined
  ): Promise<void> {
    if (!this._refs.root && creationProps) {
      const profileGroup = Group.create({ owner: this })
      profileGroup.addMember("everyone", "reader")
      this.profile = UserProfile.create(
        { name: creationProps.name },
        { owner: profileGroup }
      )
      this.root = UserRoot.create(
        {
          name: creationProps.name,
          username: creationProps.username,
          website: creationProps.website,
          bio: creationProps.bio,

          personalLinks: PersonalLinkLists.create([], { owner: this }),
          personalPages: PersonalPageLists.create([], { owner: this }),

          // not implemented yet
          topicsWantToLearn: ListOfTopics.create([], { owner: this }),
          topicsLearning: ListOfTopics.create([], { owner: this }),
          topicsLearned: ListOfTopics.create([], { owner: this })
        },
        { owner: this }
      )
    }
  }
}
// TODO: need?
// class ListOfGlobalTopics extends CoList.Of(co.ref(GlobalTopic)) {}
